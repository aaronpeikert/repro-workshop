[["index.html", "Reproducible Research How to do the same thing more than once About", " Reproducible Research How to do the same thing more than once Aaron Peikert &amp; Hannes Diemerling 2023-09-05 About We (Aaron Peikert and Hannes Diemerling) work at the Formal Methods project at the Max Planck Institute for Human Development. Do no hesitate to contact us via email if you have any questions! If you found typos, have problems, or have suggestions for improvement please open an issue. If you found your way to this page because you are currently participating in a workshop, thank you for attending! You can head to the next chapter “Getting Started” If you are here on your own, you are welcome to try the workshop; however, we can not gaurantee that the instructions on this website will work at random time points between workshops. In case you like what you see and you want to offer this workshop at your institution, get in touch with us. You may use all materials from the GitHub repo under the CC0 1.0 Universal licence unless noted otherwise; still, we expect that you credit us where appropriate (e.g., with citing this as the source). "],["getting-started.html", "Getting Started What is reproducibility? What problems must we solve? What concepts must we know about? What software must we know about? What services will we use? What does self-paced mean? What are infoboxes? What else should I know before I start? Questions? Comments? Notes? Setup!", " Getting Started What is reproducibility? Computational reproducibility is the ability to obtain identical results from the same data with the same computer code. It is a building block for transparent and cumulative science because it enables the originator and other researchers, on other computers and later in time, to reproduce and thus understand how results came about while avoiding a variety of errors that may lead to erroneous reporting of statistical and computational results. Tools like the ‘repro’ package in R, as discussed in the text, help automate this process, making it easier for researchers to create reproducible workflows. In essence, reproducibility is the cornerstone of robust, reliable, and high-quality scientific research. What problems must we solve? copy&amp;paste mistakes inconsistent versions of code or data missing or incompatible software complicated or ambiguous procedure for reproduction What concepts must we know about? Dynamic documents Version control Software management Workflow orchestration What software must we know about? RMarkdown Git Docker Make There are alternatives to these implementations, e.g., Quarto, Jupyter, Singularity, virtualenv, SnakeMake, and many more. However, we had to decide on one set of tools. More important is that you understand for which purpose we use them then you may replace them with whatever you favor. What services will we use? You usually work on your local computer. However, in workshops, this often leads to the issues of missing/outdated/broken software setups. Therefore, we will use the prepared software environment we give you in the form of Posit Cloud (= RStudio Cloud). Additionally, we will make heavy use of GitHub (≠ Git) and GitHub Actions (∈ GitHub). What does self-paced mean? Self-paced learning is an educational approach that allows you to control the speed and intensity of your learning. This means you can learn at your own rhythm, pausing, reviewing, and progressing when it suits you best. You are encouraged to actively engage with the material, explore the content, and try to solve problems on your own before seeking help. In this course, there’s no rigid schedule to follow. You’re free to come-and-go and move through the content as you please. Remember, while it’s self-guided, you’re not alone - use the Infoboxes, explanation follows in the next paragraph, and course leaders are available to assist if you encounter difficulties you can’t resolve on your own. It is a flexible and personal way of learning designed to support you on your learning journey. What are infoboxes? There are two types of Infoboxes in this course. The first type is the Additional Infobox. These provide information to delve deeper into a topic and can be found throughout the course. Clicking on one of these boxes will take you to more in-depth material. The second type is the ReproDudes. You will find these at least once in each main chapter. If you have a question or get stuck, click on the relevant box in the chapter, and you will be redirected to ReproDude, already informed about the corresponding topic. Ask what you want to know and have a conversation. To use this, you will need a ChatGPT account, a link to which can be found below. Additional info I am an additional infobox that provides you with additional material to educate you more deeply. Click on my sister boxes for more information. ReproDude I am ReproDude, so if you have a question or are stuck on a topic, click on the appropriate ReproDude box and ask there. You will need an account with ChatGPT to use me. What else should I know before I start? In this workshop, we will go through many things, many of which are complicated. The goal today is to understand what is possible and not to achieve a complete deep technical understanding. So be kind to others and yourself and try not to get frustrated, ReproDude and the workshop leaders are there to help you if necessary! Just as you set your own pace in this course, you can also decide which tasks you do in this course. There are two types of tasks: 1. The tasks marked in green are important, and the workshop will not work if you skip any of these points or do them in the wrong order. 2. The tasks marked in blue are completely optional and are meant for trying out and experimenting. You can skip these tasks as you like. Questions? Comments? Notes? If you have any questions, comments, or notes regarding the workshop in general, you can open an issue on GitHub. Setup! If you already have an account, sign in; otherwise, sign up. GitHub If you have no GitHub account: GitHub Sign in If you already have a GitHub account: GitHub Log in Posit/RStudio Cloud If you have not used Posit/RStudio Cloud before: Use Option: “Sign Up with GitHub” Posit/RStudio Cloud Sign up If you already have a Posit/RStudio account: Posit/RStudio Cloud Log in ChatGPT If you have not used ChatGPT before: Use Option: “Sign up” ChatGPT Sign up If you already have a ChatGPT account: Use Option: “Log in” ChatGPT Log in Final Step Now, please open the project: Project If you have already logged into Posit/RStudio Cloud during the previous section, you should now see a copy of the project in front of you. Click now on “Save a Permanent Copy” in the top right-hand corner of the task bar. This ensures you have access to the project even after logging off. Congratulations! You are now ready to start the workshop; please go to the next chapter. next chapter. Video This browser does not display the video tag. "],["dynamic-documents.html", "Dynamic Documents What do you see before you? Best practices? Extended Goals? RMarkdown And now?", " Dynamic Documents ReproDude Hey, I’m your ReproDude for this chapter. If you have any questions click on me and we can talk! What do you see before you? First of all: Look around, become comfortable with Posit/RStudio Cloud. Then, locate the files pane. You are currently at your computer using Posit Cloud which hosts an R environment that you are looking at. Importantly, any actions that you do locally on your computer (e.g., with your locally installed, R, Git, terminal, etc.) will have no effect on the cloud environment. Do you feel comfortable yet? Yes? Then let’s move on. If not, take as much time as you need and move on as soon as you want, I have no more Appointments today. Best practices? To give you a sense of how reproducibility can be increased, let us look at some best practices: Open the R folder. You should now see three different R files. Click on the file R/prepare_games.R Now try to understand the code. Which of these do you already do? What could you improve? You want to see more? Just for you (same thing but more complicated): Take a look at R/prepare_inflation. Remember this blue means a task is optional. A summary? Let us summarize this in an incomplete list: List requirements early What does have to be installed? What datasets have to be aquired from where? What computational resources must be present? Use relative locations relative paths, ./data/ instead of /documents/aaron/data/ names, instead of indices, data[[\"id\"]] instead of data[[1]] Document relevant information more on this below The first two points are more or less clear, if you would like to talk about that, maybe you want to give ReproDude a try? But let’s talk about the last point. Does that mean that every piece of documentation has to be a mile long? No… not necessarily. But how do I decide what should or should not be included in my documentation? Let’s make another list: What is standard does not have to be documented. if you use, e.g., a CSV file, you do not need to explain that values a seperated by comma What is easy needs only little documentation. if your code is easy to understand, you don’t have to write a comment explaining it What is consistent only has to be documented once. sometimes things are complex and there is no way around it, e.g., you have a messy JSON dataset that must be cleaned, however, if you write a function for cleaning and reuse it, there is no need to repeat yourself in explaining how this works. If you follow the best practice of: List requirements early Use relative locations Document relevant information What is standard does not have to be documented. What is easy needs only little documentation. What is consistent only has to be documented once. you already are in a pretty good position. However, we could spend a whole day on how to code in way that is easy to follow and all the best practices there. Instead, we want to focus today on how to automate reproducibility assuming you allready have an R script that is easy to understand. For everything else we are missing the time today and there are simply to many different skill levels present in such a workshop. Extended Goals? The goal today is conceptually simple: raw data → automatically → final paper We want to create a system that takes your analysis and reproduces it automagically. Therefore, whenever you make a change to your analysis you get the results without lifting a finger. Crucially, since it is reproduced by an external system this proofs to you that your results are reproducible by any external person. In fact, when I say results, what I really mean is the whole article including text, tables, and figures. An added benefit is that collaborators, readers, and the future you, can simply change things online withou installing anything and can expect to get the full paper reproduced with these changes. The goal, therefore is create a neat bundle of the following components that we can send to others so they have everything they need for reproduction: code + data + text + history + software + workflow But haven’t we already looked at parts of it? Yes! code + data + text + history + software + workflow We have already dealt with code and data (or rather I assume that is solved). This is a schematic overview of the system we want to build today: We build this system to solve the following problems: copy&amp;paste mistakes inconsistent versions of code or data missing or incompatible software complicated or ambiguous procedure for reproduction Using: RMarkdown Git Docker Make That is, the component text has the problem of copy&amp;paste mistakes and we use RMarkdown to solve the problem. RMarkdown RMarkdown I will give you more information about RMarkdown by taking you to their documentation. Now let’s go back to your R cloud environment. Open the file inflation.Rmd. If you are still in the R folder, you have to go up one level again. Take a minute to skim the document (Or even two). Click on knit. And if you want to admire more examples, click on RMarkdown Gallery. Metadata (YAML) Now that you have looked at at least one RMarkdown example, did you notice the following part?: --- title: &quot;Inflation Data&quot; author: &quot;Aaron Peikert&quot; date: &quot;2023-09-05&quot; output: html_document repro: packages: - here - tidyverse - lubridate - aaronpeikert/repro@fc7e884 scripts: - R/prepare_inflation.R data: - data/raw/inflation.rds --- This is the metadata, in YAML format, for the RMarkdown document. Change html_document to pdf_document Knit again. What happened? You want to experiment more? Change the author or date field. Try the tufte-format (click me). Text (Markdown) In the document, you probably also noticed this part: The dataset we use stems from the [Bank of England Research datasets](https://www.bankofengland.co.uk/statistics/research-datasets). I quote: &gt; This dataset contains the individual responses to our Inflation Attitudes Survey, a quarterly survey of people’s feelings about inflation and other economic variables like the interest rate. This is Markdown and we will use it to write and format the actual text. Make something bold and something else italic: This is **bold**, while this is *italic*. Go to Help → Markdown Quick Reference and try something out. Code (R) But there is yet another component in the document. This part contain code blocks like: ```{r} inflation %&gt;% group_by(date) %&gt;% summarise(across(c(perception, expectation), ~ mean(., na.rm = TRUE)), .groups = &quot;drop&quot;) %&gt;% pivot_longer(c(expectation, perception)) %&gt;% ungroup() %&gt;% ggplot() + geom_line(aes(date, value, color = name)) + NULL ``` These code blocks can be not only R code but also Julia, Python, Octave and other programming languages. Add a R code chunk (Ctrl + Alt + I) and inline code: A code chunk is for longer code/output: ```{r} with(mtcars, plot(hp, mpg)) ``` Inline code is for single numbers/short text: We have 32 cars. Include all the code in output with: knitr::opts_chunk$set(echo = TRUE) Try using python: ```{python} print(&quot;Hello World! Python here, do you miss R already?&quot;) ``` And now? Congratulations, another section done! Before we continue, let’s take a quick look together at what we have just done. We have now one component more in our toolbox. code + data + text + history + software + workflow And with that we solved our first Problem on the list: copy&amp;paste mistakes inconsistent versions of code or data missing or incompatible software complicated or ambiguous procedure for reproduction And which software did we just used for this?: RMarkdown Git Docker Make Final Step Now please go through what we have just done and all the software we use. You are currently at your computer using Posit Cloud which hosts an R environment where you used RMarkdown to write some examples. Shall we both take a short break or do you want to continue straight away? You are ready for the next chapter. next chapter. Video This browser does not display the video tag. "],["version-control.html", "Version Control What now? Git? And now?", " Version Control ReproDude Hey, I’m your ReproDude for this chapter. If you have any questions click on me and we can talk! What now? Let’s get on with it then! What’s next? Let’s take another look at our components, which ones are we examining now? code + data + text + history + software + workflow History? Maybe a look at our problem and software solution list will help to shed some light on the matter. Problem list: copy&amp;paste mistakes inconsistent versions of code or data missing or incompatible software complicated or ambiguous procedure for reproduction Software solution list: RMarkdown Git Docker Make So does that mean we use Git (and Github) to avoid the problem of inconsistent versions of code and data? That sounds good; let’s get started right away! Git? Figure 1: Git Overview Git is an amazing tool that helps you keep track of changes in your project, just like having a magical time machine for your work. It’s like having a superpower for managing files and projects, especially when you’re coding, although it can be used for any type of project that involves files (think RMardown!). Imagine you have a project, and it’s like a journey represented by a single line called the ‘main’ branch. Each point along this line is a different version of your project, capturing the moments when you’ve made changes and saved them (committed them). It’s like preserving snapshots of your progress, allowing you to travel back in time and see how your project evolved. Hands on! Git I will lead you to a cheat sheet for git, who likes remembering? Now that we’ve cleared that up, let’s get back to the code. Modify this code and run it: # use a function without loading the package: # package::function usethis::use_git_config( user.name = &quot;Jane Doe&quot;, # &lt;-- change to your name user.email = &quot;jane@example.org&quot;, # &lt;-- and your email init.defaultBranch = &quot;main&quot;) # &lt;-- not necessary but kinder than &#39;master&#39; You will need to do this once for each computing environment. Run this code to activate git: usethis::use_git() You are then asked to confirm some actions, simply choose the option that means approval in these situations (also if you see this kind of dialog in the future). You will need to do this once per project. Figure 2: Your current position You have now initialized Git, our time machine, for your project. As you can see in figure two, you are on the position called Current and Git has saved Version 1, which has no changes to your current point. But we can’t travel to another time yet, because we are in the first version and there is no history from Git’s point of view. Make history Let’s make history then. To do that we need to change something in the document. How about the plot in the code? Remember, we are currently in inflation.rmd. The plot is ugly very functional. Beautify it a bit. Some suggestions: theme_minimal() + ylab(&quot;subjective inflation in %-points&quot;) + labs(color = &quot;&quot;) + theme(legend.position = c(.1, .9)) + Plot the two or five year expectation. [Hint: Swapping the variable E1y_all in R/prepare_inflation.R should to the trick.] Great, now we have changed something! Can we now just jump back and forth between now and the start, like a time machine should be? Almost. We need to tell Git beforehand, that the current state should become a new point in time. In Git, we cannot travel completely free in time, but only between time points we set. This is exactly the kind of point in time we are setting now through Git commits. Create a commit: Git pane → Click checkbox of changed files → Commit → Message → Commit [Note: The Git pane is usually in the same window as the environment variables.] What can you do when you delete a file by accident? Can Git help when you loose your computer / access to Posit Cloud? Now we have performed our first commit! What does our Git history look like now? Figure 3: Your current position So now we have created a second version that is our modified code and saved it as a point in time. And our Current position is identical to version 2 but different from version 1 (we have changed the plot). But so far, everything is only local. If I try to contribute to your code from the other side of the world, it won’t work because I don’t have direct access to your local Git repository. To provide remote access for you, me, and anyone else you like or at least collaborate with, we will use GitHub. GitHub GitHub is like a virtual space where you can save and share your code with others. It makes working with Git easy and accessible, allowing you to collaborate with teammates, track changes, and keep your code safe in one place online. Let us Introduce our-self to GitHub. To get a GitHub pat/token run: usethis::create_github_token(description = &quot;Token for Repro Workshop 2023 Test&quot;) Activate scope write:packages. Modify expiration. Today is enough. Copy token. You will need to do this once for each computing environment. Now we need to store this Token, it is like our Passport for entering the GitHub Country. Set token: gitcreds::gitcreds_set() # &lt;-- Token must *not* go into brackets, paste when asked Verify that everything is in order: usethis::gh_token_help() You will need to do this once for each computing environment. And what have we done now? Figure 4: GitHub status So far, we have only authenticated, so we have permission to enter the realm of GitHub, but we haven’t sent anything there yet. [Hint: If pushing code fails or asks for the password, we have triggered spam detection. In this case, we will have to repeat the GitHub handshake.] Now let’s use GitHub! To activate GitHub and upload your files to the public web: usethis::use_github() Private alternative/ upload to the non-public web (don’t use now): usethis::use_github(private = TRUE) Can you simply use code from others that you find on GitHub? Try usethis::use_mit_license() Up for a challenge? Try usethis::use_readme_rmd() That’s it! And what does our history look like now? Figure 5: GitHub status As seen in figure 5, we now have an identical copy of our Git history on GitHub as well! And now? Congratulations, another section done! Before we continue, let’s take a quick look together at what we have just done. We now have one more component in our toolbox. code + data + text + history + software + workflow And with that, we solved our second problem on the list: copy&amp;paste mistakes inconsistent versions of code or data missing or incompatible software complicated or ambiguous procedure for reproduction And which software did we use for this?: RMarkdown Git Docker Make Final Step! Now please go through what we have just done and all the software we used. You are currently at your computer using Posit Cloud, which hosts an R environment where you used Git to create a traceable History and saved it online with GitHub. But that was all for this section. Shall we both take a short break or do you want to continue straight away? You are now ready for the next chapter. next chapter. Video This browser does not display the video tag. "],["software-management.html", "Software Management What now? Docker? And now?", " Software Management ReproDude Hey, I’m your ReproDude for this chapter. If you have any questions click on me and we can talk! What now? And on to another chapter! What’s next? Like last time, let’s look at our components. Which ones are we examining now? code + data + text + history + software + workflow Software? Maybe a look at our problem and software solution list will help us again. Problem list: copy&amp;paste mistakes inconsistent versions of code or data missing or incompatible software complicated or ambiguous procedure for reproduction Software solution list: RMarkdown Git Docker Make So does that mean we use Docker to avoid the problem of missing or incompatible software? This sounds like a program I would have needed a while ago. Then let’s jump right in! Docker? Let me introduce Docker: your software superhero! It saves you from compatibility chaos and missing dependencies. Docker images effortlessly make all required software availible on any computer (with Docker installed). Docker operates on the principle of containerization, which essentially means encapsulating your software application in a bundle with its own operating system, also known as a container. This approach provides a unified and consistent environment that is isolated from the rest of your system, ensuring that your software runs the same way, no matter where it is deployed. Short note from the management, this workshop uses a lot of automation to automate reproducibility, e.g., to configure software, fill templates, interact with Git/GitHub etc. Among them: usethis gitcreds gh and a package from Aaron: repro These packages are “training wheels” and are not strictly required; you could configure everything manually. Nevertheless, the use of repro prevents headaches by automating many steps. [Besides, it would go way beyond the scope of the workshop if we were to do every step ourselves.] repro! repro I will lead you to a deep dive of the repro package. Then let’s dive into the repro package together. repro uses metadata in Rmds to infer (among other things) the software environment required. Trigger this mechanism using: repro::automate() Take a look at the newly generated file Dockerfile. Remove all, if any, python chunks. Commit changes. (Do not push.) Add any package of your liking to any Rmd and run repro::automate() Take a look at the file .repro/Dockerfile_base and friends. How would you change the R version used? Now we will use GitHub action (GHA). GitHub action is a cloud service that runs software when certain events trigger it (like Pushing something up to GitHub). Add a GitHub Action to build the required Docker image with repro::use_gha_docker() To trigger the action, commit and push your changes. Browse through the actions: usethis::browse_github_actions() Take a look at .github/workflows/push-container.yml. When is the action triggered? That’s it. But what have we actually just done? We created Dockerfiles using the repro package and then automated the building of Docker images by setting up GitHub Action. These Docker images now ensure a reproducible software environment! At the moment, we have not used the newly build image, that follows in the next step. And now? Congratulations, we are approaching the finish line! Before we continue, let’s take another quick look together at what we have just done. We now have one more component in our toolbox: code + data + text + history + software + workflow And with that, we solved our third problem on the list: copy&amp;paste mistakes inconsistent versions of code or data missing or incompatible software complicated or ambiguous procedure for reproduction And which software did we just use for this?: RMarkdown Git Docker Make Final Step! Now please go through what we have just done and all the software we used. You are currently at your computer using Posit Cloud, which hosts an R environment where you used the repro package and GitHub to generate a Docker image to ensure a reproducible software environment. That ends this section. Should we pause for a short break or proceed without interruption? You are now ready for the next chapter. next chapter. Video This browser does not display the video tag. "],["workflow-orchestration.html", "Workflow Orchestration What now? Make? And now?", " Workflow Orchestration ReproDude Hey, I’m your ReproDude for this chapter. If you have any questions click on me and we can talk! What now? We have already reached the last chapter of content! What is it about? As usual, let’s look at our components. Which is the last missing piece for fully automating reproducibility? code + data + text + history + software + workflow Workflow, I think I heard of that. Let’s peek again at our problem and software solution lists to be sure. Problem list: copy&amp;paste mistakes inconsistent versions of code or data missing or incompatible software complicated or ambiguous procedure for reproduction Software solution list: RMarkdown Git Docker Make So that means we use Make to avoid the problem of complicated or unclear procedure for reproduction? Let’s jump right in! Make? Make Click on me for the documentation of Make! To understand what Make is, let’s take a step back. To do that, let’s move on to a topic that I’m really passionate about. Food. And even one step further back, cooking. What is cooking? Besides the definition of content, cooking is a sequence of dependencies. Let’s take a look at my favorite recipe. Arrabbiata sauce, or sugo all’arrabbiata in Italian, is a spicy sauce for pasta made from garlic, tomatoes, and dried red chili peppers cooked in olive oil. “Arrabbiata sauce” from Wikipedia under CC BY-SA 3.0 And what are the steps in this masterpiece of craftsmanship? Arrabbiata sauce, or sugo all’arrabbiata in Italian, is a spicy sauce for pasta made from garlic, tomatoes, and dried red chili peppers cooked in olive oil. “Arrabbiata sauce” from Wikipedia under CC BY-SA 3.0, emphasis added Despite the beauty inherent in this recipe, we also want to formalize it. Let’s see how this recipe looks in a formalized version: arrabiata.pdf: arrabiata.Rmd sauce.csv R/pasta.R Rscript -e &quot;rmarkdown::render(&#39;arrabiata.Rmd&#39;)&quot; sauce.csv: R/cook.R tomatoes.zip aromatics.yaml Rscript -e &quot;source(R/cook.R)&quot; aromatics.yaml: R/sizzle.R garlic.txt chili.json Rscript -e &quot;source(R/sizzle.R)&quot; Let’s break it down for our understanding. arrabiata.pdf is our sauce that we want to have. This sauce is created based on the files arrabiata.Rmd, our recipe, using sauce.csv and /pasta.R. sauce.csv is created with R/cook.R with the raw materials tomatoes.zip and aromatics.yaml. aromatics.yaml in turn is created by R/sizzle.R with the raw materials garlic.txt and chili.json. If you have trouble understanding the recipe, don’t worry, we’re all just virtual people. Maybe a conversation with ReproDude will help you? After looking at the arrabbiata sauce, here is another example of a culinary masterpiece. Brownies. Just kidding, let’s get out of here or I’ll need a lunch break. Instead, let’s point out the key features of this kind of recipe by Make: Missing ingredients will be generated, e.g., if the cleaned data is missing, the raw data is first cleaned. Newer ingredients trigger updates, e.g., new data leads to the recreation of the whole manuscript. Always the same “button” that triggers reproduction, e.g., regardless of programming language, file format, and intermediate steps. And the great thing is that repro::automate() automatically generates recipes for Rmds, only deeper nested dependencies must be added manually. Hands on! But now we have had enough thinking, let’s go back to the code! Go to the terminal (Alt + Shift + M) and type make inflation.pdf [Hint: If you did not change output: html_document to output: pdf_document in inflation.Rmd you need to use .html instead of .pdf.] Delete inflation.pdf. Add inflation.pdf to the target all (e.g.,: all: inflation.pdf) in the Makefile. Go to the terminal (Alt + Shift + M) and type make Run: make -B --dry-run [Hint: -B means rebuild everything. –dry-run means do not actually run the commands.] And now that we’ve created the recipe, let’s take it one step further and Make it in the cloud. Run repro::use_make_publish() Paste the following into the Makefile: publish/: inflation.pdf include .repro/Makefile_publish Back to the Console, run repro::use_gha_publish() Commit and push. Inspect .repro/Makefile_publish. Ready yet? All right, what did we just do? We created and send a Makefile to the cloud using Make and the repro package. This makefile will ensure that we can track how our sauce is created! And now? Congratulations, we are more or less near the finish line! Before we finish, let’s take one more quick look together at what we just did. We now have all the components from our toolbox together. code + data + text + history + software + workflow And with that, we solved our last problem on the list: copy&amp;paste mistakes inconsistent versions of code or data missing or incompatible software complicated or ambiguous procedure for reproduction And which software did we use?: RMarkdown Git Docker Make Almost the Final Final Step! Now please go through all the things we just did and all the software we used. You are currently at your computer using Posit Cloud, which hosts an R environment where you used Make and the repro package to generate a Makefile which automates the reproducibility of build processes. You have now reached the advanced status of reproducibility; there is only one last step to show the world what we have learned here. Publish With this step we will now publish the document automatically, for this we will use GitHub again. Go back to GitHub. Go to Settings → Pages and change none to gh-pages. Go to actions and wait for the new action to finish. Inspect the published PDF online (change username): yourusername.github.io/project/inflation.pdf Change something, e.g., make the plot ugly again, then commit and push. Takes ~5min or so. The great thing about this automation is that it now automatically builds and publishes your document every time you push a new version to GitHub. And with that, we have concluded the workshop in terms of content! In the following chapter, we’ll just go through some suggestions on how you can continue your Reproductions journey. You are now ready for the last chapter. next chapter. Video This browser does not display the video tag. "],["before-you-go.html", "Before you go Ressources Hard to say Goodbye", " Before you go Welcome to the end of our journey! Now that we have everything behind us, let’s take another look at how the individual components work together. Let’s look at everything together again. And does it make more sense to you now? If not, don’t worry; practice makes perfect. Now that we have gathered a lot of knowledge, the journey together is over, but hopefully, your journey has just begun. To help get you started, here are a few resources. Ressources Starter First, we started with RMarkdown. This was the part where we familiarized ourselves with the files RMarkdown Click on me and I will lead you to R Markdown: The Definitive Guide. Secondly, we have Git, with which we have recorded our versions and can travel in time. Git Click on me and I will lead you to a specific Git tutorial. Third, we have GitHub, which allows us to store our Git versions online and do a variety of additional things, such as GitHub Actions. But an even better idea than to use the resources here is to start a small project on GitHub together with a friend. GitHub Click on me and I will lead you to a Deep Dive tutorial for GitHub. That’s it for the starter tutorials. Advanced To go deeper, I would recommend you to read the following: Read: Peikert, A., van Lissa, C. J., &amp; Brandmaier, A. M. (2021). Reproducible Research in R: A Tutorial on How to Do the Same Thing More Than Once. Psych, 3(4), 836–867. https://doi.org/10.3390/psych3040053 And to give you a direct starting point from here, how about this: Adept the project we created today so that it becomes one of your projects (with your data, your analyses). Digging really Deep As you have probably noticed, we are still missing a deep dive into some of the software we have directly or indirectly used. These are a bit more complicated than what we have described so far, so let’s just bundle them into this section. First, Make, which we used to build our recipes. Make Click on me and I will lead you to minimal make: A minimal tutorial on make. And after you’ve looked at that: Simplify a complicated pipeline Next up is Docker. Docker is a great program once you get it running. If you enjoy a bit of a headache: Docker: get Docker installed. And if you enjoy severe headaches, welcome to LaTeX. Try to learn LaTeX Hard to say Goodbye If you’re reading this, you’re all done with the workshop! Unless you’re just passing through, in which case I hope to see you again later. Thank you for taking the time to explore the big world of reproducibility with me. Also, I want to thank my developers, Aaron Peikert and Hannes Diemerling. And then it only remains for me to say goodbye to you; it was nice to have you here! "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
